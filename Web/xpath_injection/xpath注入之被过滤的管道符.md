##xpath注入之被过滤的管道符

在这个挑战中，我们必须检索数据库中所有用户的密码，而不使用管道字符。我们最初的查询如下所示：

`/xmlfile/users/user[username='OUR_INPUT_HERE']/username`

据说无法像使用SQL注入攻击一样注释XPath查询的结束。虽然这是真的，但我们确实有一个提前截断XPath查询的选项：空字节截断。

基于C语言使用空字节作为字符串终止符，并在到达空字节时停止读取赋给它的任何字符串。由于libxml是用C语言编写的，如果存在空字节，我们的PHP脚本（实际上读取整个字符串）给它的XPath查询将被截断。空字节的URL编码版本是`％00`。

当我们控制在用户对象中的字段被选中之前的查询部分时，我们可以截断查询的指定部分，使其仅返回用户名。我们可以通过关闭条件并用空字节截断其余部分来完成此操作。最后的查询将如下所示：

`/xmlfile/users/user[username='']%00']/username`

而libxml会将其读为：

`/xmlfile/users/user[username='']`

我们唯一的问题是，这只会返回任何空白用户名的用户的密码，这是不太可能返回任何数据。因此，我们可以使用`' or '1'='1']`技巧与空字节一起为所有用户提取所有数据，其中包括密码数据。最终的查询如下所示：

`/xmlfile/users/user[username='' or '1'='1']%00']/username`

它由libxml读取，如下所示：

`/xmlfile/users/user[username='' or '1'='1']`

这将返回整个用户数据集，而不使用管道字符。

所以，挑战5的一个正确答案是：

`' or '1'='1']%00`