##盲注遍历节点值

在之前的挑战中，我们能够通过将查询/*的结果与两个查询结合在一起来检索所有XML数据，这两个查询旨在从原始查询的其余部分中返回任何我们创建的查询。

在这个挑战中，我们必须进行多次查询才能检索所有数据，因为我们一次只能检索一个值。因此，我们遍历整个数据集，一次一个节点。

首先，我们必须迭代数据集并确定其结构。这样做更容易，因为我们可以在条件内进行XPath查询。我们可以遍历每个子节点并引用它们中的每一个：

`/*[1]`

`/*[2]`

等等…

这也可以分层使用，如下所示：

`/*[1]/*`

为了确定有多少个子节点，我们可以使用`count()`函数。首先，我们需要一个有效的用户名。这可以通过`1' or position()=1 and '1'='1`来实现。我们发现`jsmiley`是一个有效的用户。我们可以改变条件，要求用户名是`jsmiley`，并且基于节点数的某些语句是真实的。示例攻击字符串如下所示：

`jsmiley' and count(/*)<10 and '1'='1`

这会导致查询如下所示：

`/xmlfile/users/user[username='jsmiley' and count(/*)<10 and '1'='1']/username`

如果根的子节点数小于10，我们会看到返回“jsmiley”用户名。这样，我们可以慢慢地学习数据集的层次结构，通过查询来查询。一旦我们知道了层次结构，我们就可以开始使用类似于挑战1的技术来撤回整个层次结构中每个节点的值，如下所示：

`']|/*[1]/*[1]/*[1]/*[3]|/a['a`

通过确定层次结构并拉回每个节点，我们可以一次重建整个文档，一个值。由于`count()`等函数只能在条件内使用，因此确定数据集层级的过程是盲目的，但数据提取不是。