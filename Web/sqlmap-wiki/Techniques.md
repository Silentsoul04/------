# 技巧

sqlmap能够发现并利用以下五种不同的SQL注入**方式**:

* **基于布尔型盲注**:sqlmap会替换掉HTTP请求中受到影响的参数，或者在参数的后面加上一些东西，比如语法上有效且包含一个`SELECT`子句的SQL字符串语句，或是任何能够使用户检索到输出的SQL语句。每次收到HTTP应答，sqlmap通过比较它与原始请求headers/body的不同，就可以一点一点地推导出注入语句的输出。或者，用户可以提供一个字符串或真表达式来匹配值为真的页面。在这一技术中，sqlmap运用到了二分法，这使得它最多能捕捉到7个HTTP请求中每一个输出的每一个字母。有时候输出不在普通字符集的明文中，sqlmap可以调整算法进行更大范围内的运算来发现输出内容。
* **基于时间型盲注**:sqlmap会替换掉HTTP请求中受到影响的参数，或者在参数的后面加上一个语法上有效的SQL字符串语句，这个字符串语句中包含查询语句，它能使后端DBMS产生延迟并返回一个数字，这个数字就是后端DBMS延迟的秒数。对每次HTTP应答，sqlmap通过对比HTTP应答和原始请求时间上的不同，来一点一点地推导出注入语句的输出。与基于布尔型盲注一样，这个方法也用到了二分法。
* **基于错误**: sqlmap会替换掉HTTP请求中受到影响的参数，或者在参数的后面加上一个与数据库相关的错误信息引起的语句，通过分析HTTP应答的头部和body来搜寻DBMS错误信息，这些错误信息中包含被注入的预先定义的字符链，其中就有子查询语句的输出。这种方法只在网络应用被配置用来暴露后端DBMS错误信息时才会奏效。
* **基于联合查询**:sqlmap在受到影响的参数后加上以`UNION ALL SELECT`开头的且语法上有效的SQL语句。当网络应用页面没有检测出`SELECT`语句中`for`循环的输出或是类似的东西，这个方法就会奏效。这样一来，查询输出的每一行都会被打印在页面目录上。当语句的输出在`for`结构中没有循环时，sqlmap还可以利用**部分（单入口）联合查询SQL注入**的漏洞，但此时只会显示第一个查询输出的入口。
* **栈查询**, 也叫**piggy backing**:sqlmap会检测网络应用是否支持栈查询，如果真的支持，它就会在HTTP请求中给受影响的参数后面加上一个分号(`;`)，后跟需要执行的SQL语句。这个方法在运行SQL语句（除了`SELECT`）时会很有用，例如**数据定义（data definition）**语句或**数据操作（data manipulation）**语句，它通常会导致文件系统的读写访问和操作系统的命令执行，取决于底层后台DBMS和会话用户的权限。
